<style>
  .globe {
    fill: #060061;}

  div {
    text-align: center;
  }

  .div {
    background-color: lightsteelblue;
    overflow: auto;
  }

  .div>.tooltip {
    width: 120px;
    height: 30px;
    padding: 2px;
    font: 12px sans-serif;
    border: 0px;
    border-radius: 2px;
  }

  .div>.menuText {
    text-align: right;
    width: 10%;
    height: 100px;
    line-height: 100px;
    display: inline-block;
  }

  .div>.menuButton {
    text-align: left;
    width: 10%;
    height: 100px;
    line-height: 100px;
    display: inline-block;
  }


  html, body {
  margin:0px;
  height:100%;
  }

  .box {
  background:black;
  position:absolute;
  top:0px;
  right:0px;
  bottom:0px;
  left:0px;
  opacity:0.9;
  }

  /**
* Set rules for how the map overlays
* (information box and legend) will be displayed
* on the page. */
.map-overlay {
  position: absolute;
  top: 200px;
  left: 10px;
  background: rgba(200, 200, 200, 0.5);
  margin-right: 15px;
  font-family: Arial, sans-serif, white;
  font-color: white;
  overflow: auto;
  border-radius: 3px;
}

#features {
  top: 0;
  height: 100px;
  margin-top: 20px;
  width: 230px;
}

#legend {
  padding: 10px;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
  line-height: 18px;
  margin-bottom: 40px;
  width: 200px;
}

.legend-key {
  display: inline-block;
  border-radius: 20%;
  width: 20px;
  height: 20px;
  margin-right: 5px;
}

#legend ul {
  list-style-type:none;
}

#legend li {
  margin-left: -40px;
}


</style>

<script>
  // remove the title
  var wrappers = d3.selectAll("div.wrapper").filter(function(d, i) {return i === 2;});
  // 	console.log(wrappers);
  wrappers.remove();

  // Initialize the variables
  // Buttons
  var projectionList = ["Orthographic", "Mercator"];
  var dataList = ["Weather"];

  // Colors
  var color2 = d3.scaleLinear().domain([-50, +50]).range(["white", "#69b3a2"]);
  var color = d3.schemePaired;
  var densityColor = d3.scaleLinear().domain([900, 1200]).range(["blue", "red"]);

  // Size
  var mainWidth = window.innerWidth;
  var svgHeight = 0.9*window.innerHeight;
  var ctrlHeight = 0.1*window.innerHeight;

  //Projections
  var projection = d3.geoRobinson().scale(svgHeight / 6).translate([mainWidth / 2 -200, svgHeight / 2]).rotate([-160, 0 / 60]).precision(0.1);
  // Create the canvas
  var box = d3.select("#main");
	// create the canvas and context
	var canvas = box.append('canvas').attr('width', mainWidth).attr('height', svgHeight);
	var context = canvas.node().getContext('2d');

  var path = d3.geoPath().projection(projection).context(context);
  context.clearRect(0, 0, mainWidth, svgHeight);
    // set the background color
  context.fillStyle = '#000000'; // rectangle color
  context.fillRect(0, 0, mainWidth, svgHeight); // 4 arguments for the rect features: x, y, width and height

  // Create the control panel
	box.append("div").attr("class", "div").html(`
        <div class='map-overlay' id='legend'>
            <div style="width: 75%; margin: 0 auto; text-align: left">
                <h4>Projection</h4>
            </div>
            <div id="projection" style="width: 75%; margin: 0 auto; text-align: left">
                <input type="radio" name="projectionButton" value="Robinson" checked> Robinson <br>
                <input type="radio" name="projectionButton" value="Orthographic"> Orthographic <br>
                <input type="radio" name="projectionButton" value="Mercator"> Mercator <br>
            </div>

            <div style="width: 75%; margin: 0 auto; text-align: left">
                <h4>Data</h4>
            </div>
            <div id="loadData" style="width: 75%; margin: 0 auto; text-align: left">
                <input type="radio" name="dataButton" value="temp_C" checked> Temperature <br>
                <input type="radio" name="dataButton" value="wind"> Wind <br>
                <input type="radio" name="dataButton" value="pressure_hp"> Pressure <br>
                <input type="radio" name="dataButton" value="perticipation" > Perticipation <br>
                <input type="radio" name="dataButton" value="uvb"> UVB <br>
                <input type="radio" name="dataButton" value="relative_humidity"> Humidity <br>
            </div>
            <div style="width: 75%; margin: 0 auto; text-align: left">
                <h4>Date</h4>
            </div>
            <div  id="date" style="width: 75%; margin: 0 auto; text-align: left">
                <input type="range" name="date" id=dateSlider min="2" max="40" value="10">
            </div>
        </div>`);



  // Build the callback function for buttons
  var projectionBtn = d3.select("#projection").selectAll('input');
  projectionBtn.on('change', function(d) {
        var tmpProjectionText = this.value;
        console.log('Projection changed to ' + tmpProjectionText);
        updateProjection(tmpProjectionText);
  });

  var loadDataBtn = d3.select("#loadData").selectAll('input');
  loadDataBtn.on('change', function(d) {
        var tmploadDataBtnText = this.value;
        console.log('loadData type changed to ' + tmploadDataBtnText);
        updateLoadData(tmploadDataBtnText);
  });


  // Get Projection
  function updateProjection(pro) {
    if (pro === "Orthographic") {
        projection = d3.geoOrthographic().scale((svgHeight - 100) / 3).translate([mainWidth / 2, svgHeight / 2]).precision(0.1);
    }
    else if (pro === "Mercator") {
        projection = d3.geoMercator().scale((svgHeight - 10) / 8).translate([mainWidth / 2, svgHeight / 2]).precision(0.1);
    }
    else if (pro === "Robinson") {
        projection = d3.geoRobinson().scale(svgHeight / 6).translate([mainWidth / 2 -200, svgHeight / 2]).rotate([-160, 0 / 60]).precision(0.1);
    };
    context.clearRect(0, 0, canvas.width, canvas.height);
    render();
  };


  // Get data for display
  var displayData;

  function updateLoadData(tmpLoadData) {
      console.log(tmpLoadData);
      var v;
      displayData = loadData.map((d) => {
        // console.log(d);
          if (tmpLoadData === "temp_C") {
            v = d.temp_C;
          }
          else if (tmpLoadData === "wind") {
            v = d.wind_u;
          }
          else if (tmpLoadData === "pressure_hp") {
            v = d.pressure_hp;
          }
          else if (tmpLoadData === "perticipation") {
            v = d.perticipation_mm;
          }
          else if (tmpLoadData === "uvb") {
            v = d.uvb;
          }
          else if (tmpLoadData === "relative_humidity") {
            v = d.relative_humidity;
          };

          return {
            "x": d.x,
            "y": d.y,
            "value": v
          }
        });
        context.clearRect(0, 0, canvas.width, canvas.height);
        render();
    };

  // Load the data
  var world, loadData;
  Promise.all([
    d3.json("https://unpkg.com/world-atlas@1/world/110m.json"),
    d3.json("{{ base.url | prepend: site.url }}/assets/Sample_data_1day-2.json")
  ]).then(function(data) {
    world = data[0];
    loadData = data[1];
    // displayData = getData();
    displayData = loadData.map((d) => {
      // console.log(d);
      return {
        "x": d.x,
        "y": d.y,
        "value": d.temp_C
      }
    });
    // console.log(displayData);
    context.clearRect(0, 0, mainWidth, svgHeight);
    render();
  })

  // // Render the map and data
  // voronoiGenerator = d3.voronoi()
  //     .x(d => d.x)
  //     .y(d => d.y)
  //     .size([mainWidth, svgHeight]);
  //
  // function drawCell(cell) {
  //     if (!cell) return false;
  //     context.moveTo(cell[0][0], cell[0][1]);
  //     for (var j = 1, m = cell.length; j < m; ++j) {
  //       context.lineTo(cell[j][0], cell[j][1]);
  //     }
  //     context.closePath();
  //     return true;
  //   }


  function render() {
    // var voronoi = d3.voronoi().x(d => {projection([d.x, d.y])[0]}).y(d => {projection([d.x, d.y])[1]});
    // console.log(voronoi(displayData).polygons());

    context.clearRect(0, 0, mainWidth, svgHeight);
    var sphere = {type: "Sphere"};
		var land = topojson.feature(world, world.objects.land);
    path = d3.geoPath().projection(projection).context(context);
    // var max = d3.max(loadData, function(d) { return d.temp_C;});
    // var min = d3.min(loadData, function(d) { return d.temp_C;});
    var max = d3.max(displayData, function(d) { return d.value;});
    var min = d3.min(displayData, function(d) { return d.value;});
    var color2 = d3.scaleSqrt().domain([min, max]).range(["blue", "red"]);
    console.log("max" + max);
    console.log("min" + min);
    console.log("Colorscale" + color2);
      // set the background color
    context.fillStyle = '#000000'; // rectangle color
    context.fillRect(0, 0, mainWidth, svgHeight); // 4 arguments for the rect features: x, y, width and height

    context.beginPath(), path(sphere), context.fillStyle = "#000F", context.fill();
    context.beginPath(), path(land), context.fillStyle = "#022", context.fill();
    context.beginPath(), path(sphere), context.stroke();
    // context.beginPath();
    // for (var i = 0, n = voronoi(displayData).polygons().length; i < n; ++i) drawCell(voronoi(displayData).polygons()[i]);
    // context.strokeStyle = "#000";
    // context.stroke();


    for (var i = 0; i < displayData.length; i++) {
      var coords = projection([displayData[i].x, displayData[i].y]);
    // 					console.log(coords);
      var r = 1;
      context.beginPath();
      // Make an arc from 0 to Math.PI*2, aka a full circle
      context.arc(coords[0], coords[1], r, 0, Math.PI*2, false);
      context.fillStyle = color2(displayData[i].value);
      context.fill();
    };
  }
</script>
